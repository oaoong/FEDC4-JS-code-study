# 다이나믹 프로그래밍
- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
- `분할정복`도 큰 문제를 작은 문제로 나눠서 푸는 알고리즘이지만 둘의 차이점은 중복이 가능/불가능 한지이다.
  - 다이나믹 프로그래밍은 작은 문제의 중복이 된다.
 
## 다이나믹 프로그래밍으로 풀 수 있는 문제의 속성
1. 겹치는 부분 문제가 있는 경우 -> 큰 문제를 작은 문제로 쪼갤 수 있는 경우
2. 최적화 부문 구조 -> 작은 문제를 풀어나감으로써 큰 문제의 정답을 구할 수 있는 경우

## 파보나치 수열
- Fn = Fn-1 + Fn-2
### 큰 문제를 작은 문제로 나누기
- 큰 문제 : `N`번째 피보나치 수 구하기
- 작은 문제 : `N-1`, `N-2`피보나치 수를 구하는 문제

👀 재귀를 사용할 수 있지만 아래 그림처럼 많은 계산이 중복된다.

![image](https://github.com/prgrms-web-devcourse/FEDC4-JS-code-study/assets/117630589/865ec455-7113-4e6f-90aa-ea75042f8a9e)

### 최적화 부문 구조
- 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면,
  - `서울` -> 대전 -> 대구 -> `부산`
  - 대전에서 부산을 가는 가장 빠른 길은? 대구를 거쳐야 한다.
- 만일 대전에서 부산을 가는 가장 빠른 길이 울산을 거쳐야 한다면?
  - 서울 -> 대전 -> 울산 -> 부산이 되는 것이 맞다.
- `작은 문제의 정답을 이용하여 큰 문제의 정답을 구할 수 있음`

#### 피보나치 수열의 경우
- 몇번째 피보나치 수를 구하든지에 상관없이 n번째 피보나치수는 항상 동일하다.

## 다이나믹 프로그래밍 최적화의 핵심
- 각 작은 문제는 한 번만 풀어야 한다.
- 최적화 부문 구조를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다.
- 정답을 한 번 구했으면, 어딘가에 메모해놓는다.
- 메모하는 것을 코드에서는 배열로 구현할 수 있다.
- 메모한다고 해서 Memoization 이라는 용어를 쓴다.

[유데미 외국인 강의를 듣고 정리한 DP의 유형](https://velog.io/@nabi5986/JS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)


## 결론
메모이제이션을 하지 않으면, O(대략 피보나치 n번째까지의 총합)만큼의 시간에 값을 구하게 된다. 대략 O(2n제곱) 만큼의 시간복잡도가 걸린다.
메모이제이션을 하면 대략 O(3n)만큼의 시간에 값을 구하게 된다.

### Top-down과 Bottom-up의 시간차이는?
- Top-down 방식 : 하향식 방법으로, 가장 큰 문제를 방문 후 작은 문제를 호출하며 답을 찾는 방식 (메모이제이션+ 재귀함수를 호출해서 푼다.)
- Bottom-up 방식 : 상향식 방법으로, 작은 문제들부터 답을 구해가며 전체 문제의 답을 찾는 방식 (반복문을 가지고 푼다)

📌 대부분 문제에서 두가지 방식으로 모두 문제를 해결할 수 있으나 Top-down 방식이 재귀함수를 호출하기 때문에 Bottom-up 방식이 성능이 좋은 경우가 많다.


### Top-down과 Bottom-up은 서로 대체 가능한가?
- 대체 가능하다. 대부분 Top-down으로 풀 수 있는 문제는 Bottom-up으로도 풀 수 있다.


## ✔ 다이나믹 프로그래밍 문제풀이 전략
- 점화식의 정의를 세운다.
- 실제 점화식을 만든다.
