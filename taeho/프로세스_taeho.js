function solution(priorities, location) {
    
    let count = 0; //몇 번째로 실행되는지 기록하기 위한 변수
    const practice = priorities.map((v,i)=> [v,i]);
    
    while(true){
        let current = practice.shift();
        
        if(practice.some((v)=> v[0] > current[0])){
            practice.push(current);
        }else{
            count++;
            if(current[1] === location){
                return count;
            }
        }  
    }
}

/*
1. 알고리즘 or 자료구조 선택 이유
우선순위 순서대로 꺼낸다는 문제 설명을 보고 큐를 생각해서 풀었습니다. 직접 구현하진 않고 배열의 Shift()와 push()를 사용했습니다!
입력이 많지 않아서 그런건지 큐를 직접 구현하는 것과 별 차이가 없다 생각하여 편한 방식을 채택했습니다..

2. 코드 설명
2-1.  [ [ 2, 0 ], [ 1, 1 ], [ 3, 2 ], [ 2, 3 ] ]
    [ [ 1, 0 ], [ 1, 1 ], [ 9, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ] ]
    우선 자료들을 [값, 인덱스(위치)] 로 만들어 두었습니다.
2-2. 프로세스 하나를 앞에서 꺼낸 뒤 some() 메소드를 통해 꺼낸 값보다 큰 값이 배열에 존재한다면 다시 뒤로 push() 해주었습니다.
every, some - 특정 조건을 만족하는지 배열 내부의 원소를 순회하며 검사한다. true, false로 반환
every : 조건을 만족하지 않는 값이 발생하면 그 즉시 순회를 중단한다. 모두 만족해야 true (&&)
some : 조건을 만족하는 값이 발생하면 그 즉시 순회를 중단한다. 하나만 만족해도 true (||)

2-3. 우선순위대로 프로세스를 실행할 때 인덱스가 찾는 위치와 같은지 비교하고 같다면 출력해주었습니다. 

3. 시간 복잡도 or 결과
테스트 1 〉	통과 (0.29ms, 33.5MB)
테스트 2 〉	통과 (0.46ms, 33.5MB)
테스트 3 〉	통과 (0.25ms, 33.5MB)
테스트 4 〉	통과 (0.20ms, 33.6MB)
테스트 5 〉	통과 (0.07ms, 33.5MB)
테스트 6 〉	통과 (0.21ms, 33.5MB)
테스트 7 〉	통과 (0.20ms, 33.5MB)
테스트 8 〉	통과 (0.41ms, 33.5MB)
테스트 9 〉	통과 (0.16ms, 33.4MB)
테스트 10 〉	통과 (0.20ms, 33.4MB)
테스트 11 〉	통과 (0.35ms, 33.5MB)
테스트 12 〉	통과 (0.25ms, 33.6MB)
테스트 13 〉	통과 (0.31ms, 33.5MB)
테스트 14 〉	통과 (0.06ms, 33.4MB)
테스트 15 〉	통과 (0.15ms, 33.4MB)
테스트 16 〉	통과 (0.18ms, 33.5MB)
테스트 17 〉	통과 (0.37ms, 33.5MB)
테스트 18 〉	통과 (0.15ms, 33.4MB)
테스트 19 〉	통과 (0.35ms, 33.1MB)
테스트 20 〉	통과 (0.19ms, 33.2MB)

3. 기타 의견
다른 좋은 방법이 있다면 참고하며 배우고 싶습니다!!
*/