var countVowelStrings = function (n) {
  // 설명 방식이 어려워 이 부분은 인터넷을 참고했습니다.
  // 1. "a"일 때 => 1
  // 2. "ab"일 때 => "b"는 "aeiou"가 아니므로 그 전의 값 1
  // 3. "aba"일 때 => "a"는 "aeiou"이므로 그 전의 값 + 1 = 2
  // 4. "abae"일 때 => "e"는 "aeiou"이므로 그 전의 값 + 1 =3 ....
  const dp = new Array(n + 1).fill(0).map(() => new Array(5).fill(1));

  // 세로 1부터 n까지
  for (let i = 1; i <= n; i++) {
    // 가로는 3부터 0까지 거꾸로 돌려준다 => 0부터는 안 돼 절대..
    for (let j = 3; j >= 0; j--) {
      // 세로 i번째의 가로 j + 1에 i - 1에 j번째를 더해준 값으로 dp[i][j]의 값을 초기화해주자.
      dp[i][j] = dp[i][j + 1] + dp[i - 1][j];
    }
  }

  // 결국 n번째 세로에 있는 0번째 가로 요소를 return 한다.
  return dp[n][0];
};
/*
1. 알고리즘 or 자료구조 선택 이유
경우의 수들이 많은데 dfs, bfs로는 복잡도가 좀 복잡해 보여서
그 동안의 경우의 수들을 기록해두는 dp를 사용했습니다.

2. 시간 복잡도 or 결과
Runtime 57 ms
Beats 68.75%
Memory 42 MB
Beats 42.86%

3. 기타 의견
- 엄청 어려운 문제였다고 생각합니다.. 
- 최대한 dp식으로 풀어봤는데, 만약 dp문제인 걸 몰랐다면, 엄청 어려운 문제였다고 생각합니다.
- 그래서 전 dp가 엄청 약한데, 앞으로 제가 엄청 어렵다고 느끼는 문제는 전부 dp라고 생각하면 편할거같습니다 (^&^)

4. 참고 링크

*/
